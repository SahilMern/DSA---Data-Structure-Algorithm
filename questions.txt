1. Arrays
Reverse an array in place.
Find the largest and smallest element in an array.
Find the duplicate in an array of integers.

Find the missing number in an array of 1 to n.
Move all zeros to the end while maintaining the order of non-zero elements.
Find the two numbers in an array that add up to a given sum.
Implement Array.prototype.map(), reduce(), filter().
Find the intersection of two arrays.
Rotate an array by k positions.
2. Strings
Check if a string is a palindrome.
Reverse a string without using built-in methods.
Count the occurrences of a character in a string.
Find the longest substring without repeating characters.
Check if two strings are anagrams.
Implement string compression (e.g., 'aabcc' → 'a2b1c2').
Replace all spaces in a string with '%20'.
Convert a string to a number (parseInt, custom implementation).
Find the first non-repeated character in a string.
3. Linked Lists
Implement a singly linked list with basic operations (insert, delete, search).
Detect a cycle in a linked list (using Floyd’s cycle-finding algorithm).
Reverse a linked list iteratively and recursively.
Find the middle element of a linked list.
Find the nth node from the end of a linked list.
Merge two sorted linked lists into one sorted linked list.
4. Stacks and Queues
Implement a stack using an array or linked list.
Implement a queue using two stacks.
Evaluate a postfix expression using a stack.
Implement a stack with getMin() to return the minimum element in constant time.
Check for balanced parentheses in an expression using a stack.
Implement a circular queue.
5. Trees
Implement a binary tree with basic operations (insert, delete, search).
Preorder, Inorder, and Postorder traversal of a binary tree.
Check if a binary tree is balanced.
Find the height/depth of a binary tree.
Level order traversal of a binary tree.
Find the lowest common ancestor (LCA) of two nodes in a binary tree.
Convert a sorted array into a balanced binary search tree (BST).
6. Graphs
Implement a graph using an adjacency matrix and list.
Depth-first search (DFS) traversal of a graph.
Breadth-first search (BFS) traversal of a graph.
Detect a cycle in a directed graph using DFS.
Find the shortest path in an unweighted graph (BFS).
Find the shortest path in a weighted graph (Dijkstra's algorithm).
Topological sort of a directed acyclic graph (DAG).
7. Sorting and Searching
Implement bubble sort, selection sort, and insertion sort.
Implement merge sort and quick sort.
Find the kth smallest/largest element in an unsorted array.
Binary search on a sorted array.
Find the peak element in an unsorted array (where an element is greater than its neighbors).
Search in a rotated sorted array.
8. Dynamic Programming
Fibonacci sequence using dynamic programming (bottom-up and top-down).
Knapsack problem (0/1 knapsack).
Longest common subsequence.
Longest increasing subsequence.
Coin change problem (minimum number of coins for a target value).
Find the minimum number of steps to reach the end of an array.
Maximum subarray sum (Kadane’s Algorithm).
Matrix chain multiplication.
9. Recursion
Factorial of a number using recursion.
Solve the Tower of Hanoi problem.
Generate all subsets of a set (power set).
Permutations and combinations of a string or array.
Solve N-Queens problem (place N queens on an NxN chessboard such that no two queens threaten each other).
10. Bit Manipulation
Find the single number that appears once in an array (where all other numbers appear twice).
Check if a number is a power of two.
Count the number of 1s in the binary representation of a number (Hamming weight).
Find the XOR of all numbers in an array.
Find the rightmost set bit in a number.
11. Mathematical Algorithms
Check if a number is prime.
Find the greatest common divisor (GCD) using Euclid’s algorithm.
Find the least common multiple (LCM) of two numbers.
Implement integer division without using the division operator.
12. Others
Find the maximum profit from stock prices (buy low, sell high problem).
Find all pairs in an array that sum up to a given number.
Find the longest common prefix of an array of strings.
Find the median of two sorted arrays.
Advanced Questions
Trie data structure: Implement a trie with insert, search, and delete methods.
Segment tree: Implement a segment tree to handle range queries (e.g., sum, min, max).
Disjoint Set Union (Union-Find): Implement the union-find data structure to solve problems like connected components.




ChatGPT 4o mini

Log in

Create free account
You said:
most javascript dsa question ask for beigner and advance 
ChatGPT said:
ChatGPT
When preparing for Data Structures and Algorithms (DSA) questions in JavaScript, it's essential to understand the difference in complexity between beginner and advanced topics. Here are some common JavaScript DSA interview questions that range from beginner to advanced levels:

Beginner-Level DSA Questions:
Arrays:

Reverse an array.
Find the maximum and minimum elements in an array.
Merge two sorted arrays.
Find duplicates in an array.
Remove duplicate elements from an array.
Implement a function to rotate an array by k positions.
Find the missing number in an array of consecutive integers (e.g., 1 to n).
Find the common elements in two arrays.
Strings:

Reverse a string.
Check if a string is a palindrome.
Count the frequency of each character in a string.
Check if two strings are anagrams.
Implement basic string compression (e.g., "aaabbbccc" becomes "a3b3c3").
Find the longest substring without repeating characters.
Find the first non-repeating character in a string.
Sorting and Searching:

Implement the Bubble Sort algorithm.
Implement the Selection Sort algorithm.
Implement the Insertion Sort algorithm.
Find a specific element in a sorted array (binary search).
Find the index of an element in a rotated sorted array.
Linked Lists (Basic):

Implement a singly linked list.
Reverse a singly linked list.
Detect if a linked list has a cycle (using Floyd’s Cycle-Finding Algorithm).
Find the middle element of a linked list.
Merge two sorted linked lists into one sorted list.
Recursion:

Calculate the factorial of a number.
Generate Fibonacci numbers.
Solve the Tower of Hanoi problem.
Find the nth Fibonacci number using recursion.
Sum of elements in an array using recursion.
Stacks and Queues (Basic Operations):

Implement a stack using arrays or linked lists.
Implement a queue using arrays or linked lists.
Implement a stack that supports push, pop, and peek operations.
Implement a queue using two stacks.
Check if parentheses in a string are balanced.
Advanced-Level DSA Questions:
Dynamic Programming:

Find the nth Fibonacci number using dynamic programming (memoization and tabulation).
Solve the 0/1 Knapsack Problem.
Find the longest increasing subsequence in an array.
Solve the coin change problem (minimum number of coins required to make a target sum).
Longest common subsequence (LCS) between two strings.
Maximum subarray sum (Kadane's algorithm).
Edit Distance (Levenshtein Distance) between two strings.
Graph Algorithms:

Implement Depth-First Search (DFS) and Breadth-First Search (BFS) for graph traversal.
Find the shortest path in a graph using Dijkstra’s algorithm.
Solve the problem of detecting a cycle in a directed/undirected graph.
Find the shortest path in a weighted graph (Bellman-Ford algorithm).
Topological sorting of a directed acyclic graph (DAG).
Find strongly connected components in a directed graph (Kosaraju’s or Tarjan’s algorithm).
Trees (Advanced):

Implement a Binary Search Tree (BST) and basic operations (insert, delete, search).
Find the lowest common ancestor (LCA) of two nodes in a BST.
Balanced BST (e.g., AVL or Red-Black Tree).
Level-order traversal of a binary tree.
Serialize and deserialize a binary tree.
Diameter of a binary tree (the longest path between any two nodes).
Convert a binary search tree to a sorted doubly linked list.
Greedy Algorithms:

Find the minimum number of coins required for a specific sum (Greedy approach).
Job scheduling problem (maximizing profits with deadlines).
Activity selection problem.
Huffman coding.
Backtracking:

Solve the N-Queens problem.
Solve the Sudoku puzzle.
Find all subsets of a given set.
Solve the rat in a maze problem.
Find all possible combinations of a set (combination sum).
Advanced Data Structures:

Implement a Trie (prefix tree) and perform insert, search, and delete operations.
Implement a Segment Tree for range queries and updates.
Implement a Fenwick Tree (Binary Indexed Tree).
Design and implement a LRU (Least Recently Used) Cache.
Solve problems using Disjoint Set Union (Union-Find) and path compression.
String Matching Algorithms:

KMP (Knuth-Morris-Pratt) pattern matching algorithm.
Rabin-Karp string matching algorithm.
Z-algorithm for string matching.
Aho-Corasick algorithm for multi-pattern matching.
Advanced Graph Algorithms:

Solve the Traveling Salesman Problem (TSP) using dynamic programming.
Find the Maximum Flow in a network using Ford-Fulkerson or Edmonds-Karp algorithms.
Find the Minimum Spanning Tree (Prim’s or Kruskal’s algorithm).
Key Differences:
Beginner Questions: Focus mainly on basic understanding of data structures (arrays, strings, linked lists) and their simple operations (searching, sorting, inserting, etc.). They also test the ability to write basic algorithms using loops and recursion.

Advanced Questions: Involve complex problem-solving techniques, like dynamic programming, greedy algorithms, graph theory, and tree-based problems. These questions require optimization techniques, multiple approaches, and understanding of advanced data structures.

By practicing these questions, you'll gradually build up from basic to more sophisticated DSA techniques in JavaScript.

ChatGPT can make mistakes. Check important info.
?
